import type { ShikiTransformer } from 'shiki';

// Constants for diff markers
export const DIFF_MARKERS = {
  ADD: '// [!code ++]',
  REMOVE: '// [!code --]',
} as const;

/**
 * Creates a custom Shiki transformer for handling diff notation markers.
 *
 * This transformer processes VitePress-style diff markers in code:
 * - `// [!code ++]` for added lines (green background)
 * - `// [!code --]` for removed lines (red background)
 *
 * The transformer adds appropriate CSS classes and removes the marker text
 * from the final rendered output.
 *
 * @returns A Shiki transformer object
 */
export const customDiffTransformer = (): ShikiTransformer => {
  return {
    name: 'custom-diff-transformer',

    /**
     * Processes each line of code in the AST.
     *
     * For each line that contains diff markers:
     * 1. Detects the type of marker (add/remove)
     * 2. Adds appropriate CSS classes for styling
     * 3. Removes the marker text from the code
     *
     * @param node - The AST node representing a line of code
     * @param lineNumber - The current line number (1-based)
     */
    line(node: any, lineNumber: number) {
      try {
        const lineText = getTextContent(node);

        // Skip if no markers
        if (!lineText.includes('[!code')) return;

        // Process markers
        if (lineText.includes(DIFF_MARKERS.REMOVE)) {
          addCSSClass(node, 'diff remove');
          removeMarkerFromNode(node, DIFF_MARKERS.REMOVE);
        }

        if (lineText.includes(DIFF_MARKERS.ADD)) {
          addCSSClass(node, 'diff add');
          removeMarkerFromNode(node, DIFF_MARKERS.ADD);
        }
      } catch (error) {
        // Silent fail to avoid breaking rendering
      }
    },

    /**
     * Final cleanup pass on the generated HTML.
     *
     * This is a safety net that removes any remaining diff markers
     * that might have escaped the line-by-line processing.
     *
     * @param html - The complete HTML string generated by Shiki
     * @returns Cleaned HTML with all diff markers removed
     */
    postprocess(html: string) {
      // Final cleanup of any remaining markers
      return html.replace(/\/\/\s*\[!code\s*[+\-]{2}\]\s*/g, '');
    },
  };
};

/**
 * Recursively extracts all text content from an AST node.
 *
 * This function traverses the AST tree and concatenates all text values
 * from text nodes, providing the complete textual representation of a line.
 *
 * @param node - AST node to extract text from
 * @returns Complete text content of the node and its children
 */
function getTextContent(node: any): string {
  if (node.type === 'text') return node.value || '';
  if (node.children) return node.children.map(getTextContent).join('');
  return '';
}

/**
 * Adds a CSS class to an AST node's properties.
 *
 * This function safely adds CSS classes to a node, preserving any
 * existing classes and ensuring the properties object exists.
 *
 * @param node - AST node to modify
 * @param className - CSS class name to add (e.g., 'diff add', 'diff remove')
 */
function addCSSClass(node: any, className: string): void {
  const currentClass = node.properties?.class || '';
  node.properties = node.properties || {};
  node.properties.class = `${currentClass} ${className}`.trim();
}

/**
 * Recursively removes diff markers from an AST node and all its children.
 *
 * This function traverses the entire node tree and removes the specified
 * marker from any text nodes it encounters. It handles nested structures
 * created by syntax highlighting.
 *
 * @param node - Root AST node to process
 * @param marker - The specific marker string to remove (e.g., '// [!code ++]')
 */
function removeMarkerFromNode(node: any, marker: string): void {
  if (node.type === 'text' && node.value) {
    node.value = removeMarkerFromText(node.value, marker);
  }

  if (node.children) {
    node.children.forEach((child: any) => removeMarkerFromNode(child, marker));
  }
}

/**
 * Removes a diff marker from a text string using multiple strategies.
 *
 * This function employs a multi-layered approach to ensure robust marker removal:
 * 1. Exact match at line end (most common case)
 * 2. Match anywhere in text (for AST node splitting)
 * 3. Direct string replacement (fallback)
 * 4. Generic cleanup (safety net)
 *
 * @param text - The text string to clean
 * @param marker - The marker string to remove
 * @returns Text with the marker removed
 */
function removeMarkerFromText(text: string, marker: string): string {
  // Try multiple removal strategies
  const escapedMarker = marker.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

  // Strategy 1: End of line match
  let result = text.replace(new RegExp(`\\s*${escapedMarker}\\s*$`, 'g'), '');

  // Strategy 2: Anywhere in text
  if (result === text && text.includes(marker)) {
    result = text.replace(new RegExp(`\\s*${escapedMarker}\\s*`, 'g'), '');
  }

  // Strategy 3: Direct replacement
  if (result === text && text.includes(marker)) {
    result = text.replace(marker, '').trim();
  }

  // Strategy 4: Generic cleanup
  if (result === text && text.includes('[!code')) {
    result = text.replace(/\/\/\s*\[!code\s*[+\-]{2}\]\s*/g, '').trim();
  }

  return result;
}
